#' Monitoring Earth Engine task progress
#'
#' @param task List generated after an created an EE task.
#' @param eeTaskList Logical. If \code{TRUE}, all Earth Engine tasks will be
#' listed.
#' @param quiet logical. Suppress info message
#'
#' @export
#' @examples
#' \dontrun{
#' library(rgee)
#' ee_Initialize()
#' ee_monitoring(eeTaskList = TRUE)
#' }
#' @export
ee_monitoring <- function(task, eeTaskList = FALSE, quiet = FALSE) {
  if (missing(task)) {
    task <- ee$batch$Task$list()[[1]]
  }
  if (eeTaskList) {
    if (!quiet) {
      cat("EETaskList:\n")
    }
    task_list <- mapply(function(x) {
      sprintf("<Task %s: %s (%s)>", x$task_type, x$config, x$state)
    }, ee$batch$Task$list())
    if (!quiet) {
      cat("", paste0(task_list, "\n"))
      cat("\n")
    }
  }
  while (task$active() & task$state != "CANCEL_REQUESTED") {
    if (!quiet) {
      print(sprintf("Polling for task (id: %s).", task$id))
    }
    Sys.sleep(5)
  }
  if (!quiet) {
    print(sprintf("State: %s", task$status()$state))
  }
  if (task$status()$state != "COMPLETED") {
    stop(task$status()$error_message)
  }
}


#' Delete files from a either Folder or Bucket
#'
#' Delete all files from a folder (Google Drive) or a bucket
#' (Google Cloud Storage). Caution: This will permanently delete
#' your backup files generated by using ee_as_stars and ee_as_sf.
#'
#' @param name Character. Name of the folder (Drive) or bucket (GCS)
#' to delete all files into.
#' @param type Character. Name of the file storage web service. 'drive'
#' and 'gcs' are supported.
#' @param quiet logical. Suppress info message
#'
#' @export
ee_clean_container <- function(name = "rgee_backup",
                               type = "drive",
                               quiet = FALSE) {
  ee_user <- ee_exist_credentials()

  if (type == "drive") {
    if (!requireNamespace("googledrive", quietly = TRUE)) {
      stop(
        "The googledrive package is required to use rgee::ee_download_drive",
        call. = FALSE
      )
    }
    if (is.na(ee_user$drive_cre)) {
      stop(
        "Google Drive credentials were not loaded.",
        ' Run ee_Initialize(email = "myemail", drive = TRUE)',
        " to fix it"
      )
    }
    count <- 1
    try_gd_rm <- try(
      expr = googledrive::drive_rm(name, verbose = !quiet),
      silent = TRUE
    )
    while (class(try_gd_rm) == "try-error" & count < 5) {
      try_gd_rm <- try(
        expr = googledrive::drive_rm(name, verbose = !quiet),
        silent = TRUE
      )
      count <- count + 1
    }
  } else if (type == "gcs") {
    if (!requireNamespace("googleCloudStorageR", quietly = TRUE)) {
      stop(
        "The googleCloudStorageR package is required to use",
        " rgee::ee_download_gcs",
        call. = FALSE
      )
    }
    if (is.na(ee_user$gcs_cre)) {
      stop(
        "Google Drive credentials were not loaded.",
        ' Run ee_Initialize(email = "myemail", gcs = TRUE)',
        " to fix it"
      )
    }
    if (isFALSE(quiet)) {
      googleCloudStorageR::gcs_global_bucket(name)
      buckets <- googleCloudStorageR::gcs_list_objects(bucket = )
      gcs_todelete <- buckets$name
      mapply(googleCloudStorageR::gcs_delete_object, gcs_todelete)
    } else {
      suppressMessages(
        googleCloudStorageR::gcs_global_bucket(name)
      )
      suppressMessages(
        buckets <- googleCloudStorageR::gcs_list_objects()
      )
      gcs_todelete <- buckets$name
      suppressMessages(
        mapply(googleCloudStorageR::gcs_delete_object, gcs_todelete)
      )
    }
  } else {
    stop("type argument invalid.")
  }
  invisible(TRUE)
}

#' Create a download file according to its format
#' @noRd
read_filenames <- function(filename, fileformat, quiet) {
  if (fileformat == "GEO_TIFF") {
    if (length(filename) == 1) {
      read_stars(filename, proxy = TRUE, quiet = TRUE)
    } else {
      strs_list <- list()
      for (i in seq_along(filename)) {
        strs_list[[i]] <- read_stars(filename[[i]], proxy = TRUE, quiet = TRUE)
      }
      strs_list
    }
  } else if (fileformat %in% "SHP") {
    st_read(
      dsn = filename[grep("\\.shp$", filename)],
      stringsAsFactors = FALSE,
      quiet = TRUE
    )
  } else if (fileformat %in% c("GEO_JSON", "KML", "KMZ")) {
    st_read(
      dsn = filename,
      stringsAsFactors = FALSE,
      quiet = TRUE
    )
  } else {
    if (!quiet) {
      print(sprintf(
        "Download completed:%s (%s)",
        filename,
        fileformat
      ))
    }
    invisible(filename)
  }
}

#' Sort google drives files
#' @noRd
sort_drive_files <- function(drive_files, fileformat) {
  if (fileformat == "SHP") {
    shp_file <- grep(
      pattern = "(\\.prj)|(\\.dbf)|(\\.shp)|(\\.shx)",
      x = drive_files[["name"]]
    )
    selected_drive_files <- drive_files[shp_file, ]
    drive_files_sort <- selected_drive_files[order(selected_drive_files$name), ]
  } else {
    drive_files_sort <- drive_files[order(drive_files[["name"]]), ]
  }
  drive_files_sort
}

#' Sort local files
#' @noRd
ee_sort_localfiles <- function(filenames, fileformat) {
  if (fileformat == "SHP") {
    shp_file <- grep("(\\.prj)|(\\.dbf)|(\\.shp)|(\\.shx)", filenames)
    shp_file <- filenames[shp_file]
    shp_file[order(shp_file)]
  } else {
    filenames[order(filenames)]
  }
}


#' GCS or Google Drive Exist credentials?
#' @noRd
ee_exist_credentials <- function() {
  ee_path <- path.expand("~/.config/earthengine")
  read.table(
    file = sprintf("%s/rgee_sessioninfo.txt", ee_path),
    header = TRUE,
    stringsAsFactors = FALSE
  )
}



#' Fix offset of stars object
#' @noRd
ee_fix_offset <- function(image, sf_region) {
  img_proj <- image$projection()$getInfo()
  if (all(img_proj$transform %in% c(1, 0, 0, 0, 1, 0))) {
    st_bbox(sf_region)
  } else {
    rectangle_coord <- st_coordinates(sf_region)
    # image spatial parameters
    img_x_scale <- img_proj$transform[1][[1]]
    img_x_offset <- img_proj$transform[3][[1]]
    img_y_scale <- img_proj$transform[5][[1]]
    img_y_offset <- img_proj$transform[6][[1]]
    # X offset fixed
    sf_x_min <- min(rectangle_coord[, "X"])
    sf_x_max <- max(rectangle_coord[, "X"])
    x_npixels_init <- floor(abs((sf_x_min - img_x_offset) / img_x_scale))
    x_npixels_last <- ceiling(
      round(
        x = abs((sf_x_max - img_x_offset) / img_x_scale),
        digits = 6
      )
    )
    x_init_crop_img <- img_x_offset + x_npixels_init * img_x_scale
    x_last_crop_img <- img_x_offset + x_npixels_last * img_x_scale

    # Y offset fixed
    sf_y_min <- min(rectangle_coord[, "Y"])
    sf_y_max <- max(rectangle_coord[, "Y"])
    y_npixels_init <- floor(x = abs((sf_y_max - img_y_offset) / img_y_scale))
    y_npixels_last <- ceiling(
      round(
        x = abs((sf_y_min - img_y_offset) / img_x_scale),
        digits = 6
      )
    )
    y_init_crop_img <- img_y_offset + y_npixels_init * img_y_scale
    y_last_crop_img <- img_y_offset + y_npixels_last * img_y_scale
    c(x_init_crop_img, y_init_crop_img, x_last_crop_img, y_last_crop_img)
  }
}

ee_fix_world_boundary <- function(sfc, crs, epsilon = 0.0001) {
  bbox <- st_bbox(sfc)
  xmin <- bbox["xmin"]
  xmax <- bbox["xmax"]
  ymin <- bbox["ymin"]
  ymax <- bbox["ymax"]

  # if (xmax == 180) xmax <- xmax - epsilon
  # if (ymin == -90) ymin <- ymin + epsilon

  new_bbox <- c(xmin, ymin, xmax, ymax)
  class(new_bbox) <- "bbox"
  st_set_crs(st_as_sfc(new_bbox), crs)
}

#' Fix region in ee_as_thumbnail and ee_as_stars
#' @importFrom sf st_intersection st_length st_as_text st_set_crs st_as_sfc
#' @noRd
ee_fix_world_region <- function(sf_image, sf_region, quiet) {
  ee_crs <- st_crs(sf_image)
  fix_region <- suppressMessages(
    st_intersection(sf_image, sf_region)
  )

  st_is_identical <- identical(
    st_length(sf_region),
    st_length(fix_region)
  )
  sf_fix_region <- ee_fix_world_boundary(
    sfc = fix_region,
    crs = ee_crs
  )
  if (isFALSE(st_is_identical) & !quiet) {
    message(
      "NOTE: region argument does not overlap completely the image,",
      " changing region \nFrom : ", st_as_text(sf_region),
      "\nTo   : ", st_as_text(sf_fix_region)
    )
  }
  list(geometry = sf_fix_region, equal = st_is_identical)
}

#' Set crs and band names
#' @noRd
set_crs <- function(image_stars, prj_image, band_names) {
  img_crs <- as.numeric(gsub("EPSG:", "", prj_image$crs))
  st_crs(image_stars) <- img_crs
  if (length(band_names) > 1) {
    st_set_dimensions(image_stars, 3, values = band_names)
  } else {
    image_stars <- st_set_dimensions(image_stars, "bands")
    attr(image_stars, "dimensions")$bands$to <- 1
    st_set_dimensions(image_stars, 3, values = band_names)
  }
}

